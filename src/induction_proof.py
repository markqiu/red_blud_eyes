"""
归纳推理的本质解释

回答核心问题：
"他们应该在第N天离开" 这个结论是怎么从基本规则推导出来的？

关键洞察：这不是一个预设规则，而是每个村民自己在脑中推导出来的！
"""

from dataclasses import dataclass
from typing import Optional


@dataclass
class InductiveReasoning:
    """
    展示归纳推理的完整过程
    
    基本规则（只有这些是预设的）：
    1. 如果确定自己是红眼睛，必须当晚离开
    2. 所有人都是完美逻辑学家
    3. 游客宣布"至少有一个红眼睛"
    
    注意：规则中完全没有"第N天离开"这一条！
    这个结论是推导出来的。
    """
    
    def show_the_only_rules(self) -> str:
        """展示唯一的基本规则"""
        return """
╔══════════════════════════════════════════════════════════════════╗
║                     唯一的基本规则                                ║
╠══════════════════════════════════════════════════════════════════╣
║                                                                   ║
║  规则1: 如果一个村民确定自己是红眼睛，他必须当晚离开              ║
║                                                                   ║
║  规则2: 所有村民都是完美的逻辑学家                                ║
║                                                                   ║
║  规则3: 游客公开宣布"村庄里至少有一个红眼睛的人"                  ║
║                                                                   ║
║  ⚠️  注意：规则中完全没有"第N天离开"这一条！                      ║
║      这个结论需要通过逻辑推理得出                                 ║
║                                                                   ║
╚══════════════════════════════════════════════════════════════════╝
"""

    def derive_n1_case(self) -> str:
        """
        推导 n=1 的情况
        
        这是唯一直接从规则得出的情况！
        """
        return """
═══════════════════════════════════════════════════════════════════
📌 情况 n=1：唯一直接从规则推导的情况
═══════════════════════════════════════════════════════════════════

设：村庄里只有 1 个红眼睛（村民 A）

🔍 A 的观察：
   - A 看到 0 个红眼睛（其他人都是蓝眼睛）

🎤 游客宣布后 A 的推理：
   - 游客说至少有 1 个红眼睛
   - 我看到 0 个红眼睛
   - 所以那个红眼睛只能是我！

📋 应用规则1：
   - A 确定自己是红眼睛
   - 根据规则1，A 必须当晚（第1天）离开

✅ 结论：1个红眼睛在第1天离开

⭐ 关键：这是唯一直接从基本规则得出的结论！
   后面所有情况都是基于这个结论推导的。
"""

    def derive_n2_case(self) -> str:
        """
        推导 n=2 的情况
        
        注意：这个推理依赖于 n=1 的结论！
        """
        return """
═══════════════════════════════════════════════════════════════════
📌 情况 n=2：基于 n=1 的结论推导
═══════════════════════════════════════════════════════════════════

设：村庄里有 2 个红眼睛（村民 A 和 B）

🔍 A 的观察：
   - A 看到 1 个红眼睛（B）

🧠 A 在第1天的推理：
   ┌─────────────────────────────────────────────────────────────┐
   │ "假设我是蓝眼睛..."                                         │
   │                                                             │
   │ 如果我是蓝眼睛，那村里只有 1 个红眼睛（就是B）               │
   │                                                             │
   │ 根据 n=1 的结论：1个红眼睛会在第1天离开                      │
   │                                                             │
   │ 所以如果我是蓝眼睛，B 今天应该离开                           │
   └─────────────────────────────────────────────────────────────┘

😴 第1天结束：B 没有离开

🧠 A 在第2天的推理：
   ┌─────────────────────────────────────────────────────────────┐
   │ "B 昨天没离开！"                                            │
   │                                                             │
   │ 如果只有 B 一个红眼睛，他应该第1天就离开                     │
   │                                                             │
   │ B 没离开，说明 B 看到了红眼睛                                │
   │                                                             │
   │ B 能看到的人里，除了我都是蓝眼睛                             │
   │                                                             │
   │ 所以 B 看到的那个红眼睛只能是我！                            │
   │                                                             │
   │ 结论：我也是红眼睛！                                         │
   └─────────────────────────────────────────────────────────────┘

📋 应用规则1：A 确定自己是红眼睛，必须离开

👥 同时，B 也在做完全相同的推理

✅ 结论：2个红眼睛在第2天同时离开

⭐ 关键：这个推理的核心是：
   "如果只有 k 个红眼睛，他们会在第 k 天离开"
   
   这不是规则，而是 A 自己推导出来的！
   推导的基础是 n=1 的情况。
"""

    def derive_n3_case(self) -> str:
        """
        推导 n=3 的情况
        
        这个推理依赖于 n=2 的结论（而 n=2 又依赖于 n=1）
        """
        return """
═══════════════════════════════════════════════════════════════════
📌 情况 n=3：基于 n=2 的结论推导（递归链条）
═══════════════════════════════════════════════════════════════════

设：村庄里有 3 个红眼睛（村民 A、B、C）

🔍 A 的观察：
   - A 看到 2 个红眼睛（B 和 C）

🧠 A 的推理（关键的递归！）：
   ┌─────────────────────────────────────────────────────────────┐
   │ "假设我是蓝眼睛..."                                         │
   │                                                             │
   │ 如果我是蓝眼睛，那村里只有 2 个红眼睛（B 和 C）              │
   │                                                             │
   │ 🔄 现在 A 需要推理 B 和 C 会怎么想：                         │
   │                                                             │
   │    B 看到 C 是红眼睛，B 会想：                               │
   │    "如果我（B）是蓝眼睛，那只有 C 一个红眼睛"                │
   │    "根据 n=1，C 应该第1天离开"                               │
   │                                                             │
   │    第1天 C 没离开，B 推断自己也是红眼睛                      │
   │                                                             │
   │    同理 C 也这样推理                                         │
   │                                                             │
   │ 所以如果我是蓝眼睛，B 和 C 应该第2天离开（根据 n=2）         │
   └─────────────────────────────────────────────────────────────┘

😴 第1天：没人离开（A 在等待）
😴 第2天：没人离开（A 继续等待）

🧠 A 在第3天的推理：
   ┌─────────────────────────────────────────────────────────────┐
   │ "B 和 C 昨天没离开！"                                       │
   │                                                             │
   │ 如果只有他们 2 个是红眼睛，他们应该第2天离开                 │
   │                                                             │
   │ 他们没离开，说明不止 2 个红眼睛                              │
   │                                                             │
   │ 他们每人也看到了 2 个红眼睛                                  │
   │                                                             │
   │ 唯一可能：我也是红眼睛！                                     │
   └─────────────────────────────────────────────────────────────┘

✅ 结论：3个红眼睛在第3天同时离开

⭐ 递归链条：
   n=3 的推理依赖于 n=2 的结论
   n=2 的推理依赖于 n=1 的结论
   n=1 的推理直接来自基本规则
"""

    def show_the_recursive_chain(self) -> str:
        """展示递归推理链条"""
      return """
═══════════════════════════════════════════════════════════════════
🔗 推理过程（归纳链条）：为什么最后是“第 N 天离开”
═══════════════════════════════════════════════════════════════════

n=1: 唯一的红眼睛看到0个，游客说至少有1个 → 我是红眼睛 → 第1天离开
   ↓ (这是唯一直接从规则推出的！)
n=2: 每人看到1个红眼睛，假设"如果我是蓝眼睛，那只有1个红眼睛"
    根据n=1的结论，那个人应该第1天离开
    第1天没人离开 → 我的假设错了 → 我也是红眼睛 → 第2天离开
   ↓
n=3: 每人看到2个红眼睛，假设"如果我是蓝眼睛，那只有2个红眼睛"
    根据n=2的结论，那2个人应该第2天离开
    第2天没人离开 → 我的假设错了 → 我也是红眼睛 → 第3天离开
   ↓
...以此类推

所以：假如有 N 个红眼睛，那么红眼睛们就应该在第 N 天离开。

🔑 关键洞察：
1. “第N天离开”不是规则，而是从 n=1 递推出来的结论。
2. 游客宣布提供了公共时间起点 + 公共知识，使这条递推链可被所有人共同使用。
"""

    def show_mental_simulation(self, num_red: int) -> str:
        """展示一个村民完整的心理模拟过程"""
        lines = [
            f"\n{'='*70}",
            f"🧠 一个红眼村民的完整心理模拟（{num_red}个红眼睛的情况）",
            f"{'='*70}",
            f"\n我看到 {num_red - 1} 个红眼睛。",
            f"\n让我在脑中模拟所有可能情况：\n",
        ]
        
        for k in range(1, num_red + 1):
            lines.append(f"📋 假设总共有 {k} 个红眼睛：")
            if k == 1:
                lines.append(f"   → 那个人看到 0 个红眼睛")
                lines.append(f"   → 游客宣布后他立刻知道自己是红眼睛")
                lines.append(f"   → 他会在第 1 天离开")
            else:
                lines.append(f"   → 每个红眼睛看到 {k-1} 个红眼睛")
                lines.append(f"   → 他们会假设'如果我是蓝眼睛,就只有 {k-1} 个红眼睛'")
                lines.append(f"   → 根据 {k-1} 个红眼睛的情况,第 {k-1} 天应该有人离开")
                lines.append(f"   → 第 {k-1} 天没人离开，他们推断自己也是红眼睛")
                lines.append(f"   → 所以 {k} 个红眼睛会在第 {k} 天离开")
            lines.append("")
        
        lines.extend([
            "📊 我的推理过程：",
            f"   我看到 {num_red - 1} 个红眼睛",
            f"   如果我是蓝眼睛，那就只有 {num_red - 1} 个红眼睛",
            f"   根据上面的模拟，{num_red - 1} 个红眼睛会在第 {num_red - 1} 天离开",
            f"",
            f"   等待... 第 {num_red - 1} 天没人离开！",
            f"",
            f"   结论：不止 {num_red - 1} 个红眼睛，我也是红眼睛！",
            f"   我会在第 {num_red} 天离开。",
        ])
        
        return "\n".join(lines)

    def why_same_day(self) -> str:
        """解释为什么所有红眼睛必须同一天离开"""
        return """
═══════════════════════════════════════════════════════════════════
❓ 为什么所有红眼睛必须在同一天离开？
═══════════════════════════════════════════════════════════════════

这不是规则强制的，而是逻辑推理的必然结果！

🔍 分析：假设有 N 个红眼睛

每个红眼睛都看到 N-1 个红眼睛，他们都在做完全相同的推理：

  ┌────────────────────────────────────────────────────────────┐
  │ "如果我是蓝眼睛，那就只有 N-1 个红眼睛"                    │
  │ "N-1 个红眼睛会在第 N-1 天离开"                            │
  │ "第 N-1 天没人离开..."                                     │
  │ "所以我也是红眼睛！我必须在第 N 天离开"                    │
  └────────────────────────────────────────────────────────────┘

💡 关键点：

1. 所有红眼睛看到的红眼睛数量相同（都是 N-1）
2. 所有红眼睛用同样的逻辑推理
3. 所有红眼睛在同一时刻得出同样的结论
4. 因此他们必然在同一天离开

🔄 为什么不能更早或更晚？

不能更早：
  - 在第 N-1 天之前，没人离开是"正常的"
  - 红眼睛还在等待验证假设

不能更晚：
  - 第 N-1 天没人离开是关键信息
  - 这个信息让每个红眼睛同时推断出自己是红眼睛
  - 根据规则，确定后必须当晚离开

不能单独离开：
  - 每个红眼睛在得出结论之前的信息完全相同
  - 他们在同一时刻得出相同结论
  - 没有任何理由让某人比其他人更早确定
"""


def main():
    """运行完整的归纳证明演示"""
    proof = InductiveReasoning()
    
    print(proof.show_the_only_rules())
    print(proof.derive_n1_case())
    input("按回车继续...")
    
    print(proof.derive_n2_case())
    input("按回车继续...")
    
    print(proof.derive_n3_case())
    input("按回车继续...")
    
    print(proof.show_the_recursive_chain())
    input("按回车继续...")
    
    print(proof.show_mental_simulation(5))
    input("按回车继续...")
    
    print(proof.why_same_day())


if __name__ == "__main__":
    main()
